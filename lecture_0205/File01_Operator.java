package lecture_0205;

public class File01_Operator {
	public static void main(String[] args) {
		// 연산자(Operator)
		
		// 형 변환
		//  - 데이터의 타입을 변환하기 위한 연산
		//  - 컴파일러는 연산자의 피 연산자들의 타입이 다르면
		//    일치시키기 위해 형 변환을 자동으로 해주거나
		//    오류를 발생시킨다.
		//	- 형 변환의 종류
		//		1. 자동 형 변환
		//			: 컴파일러가 알아서 변환해주는 경우
		//			: 피 연산자의 타입이 서로 다른 경우에
		//		      크기가 작은 타입에서 큰 타입으로 변환
		//			  또는 정수에서 실수 타입으로 변환
		//		2. 강제 형 변환
		//			: 개발자가 필요에 의해 강제로 변환해야하는 경우
		//			: 크기가 큰 타입에서 작은 타입으로 변환
		//			  또는 실수에서 정수 타입으로 변환
		//			: 피 연산자의 타입이 서로 같은 경우에
		//			  다른 타입으로 결과를 얻어야하는 경우
		//			→ 변환해야할 표현식 앞에 소괄호와 함께 데이터 타입을 명시
		//			   ※ 데이터의 손실이 발생할 수 있다.
		
		// int 형 데이터를 double 형 변수에 저장시키기 위해
		// int 형 데이터를 double 형으로 변환
		//  → 자동 형 변환
		double n1 = 100;
		// int 형 데이터를 long 형 변수에 저장시키기 위해
		// int 형 데이터를 long 형으로 변환
		//  → 자동 형 변환
		long n2 = 100;
		
		// double 형 데이터를 int 형 변수에 저장시킬 수 없기 때문에
		// 컴파일 오류가 발생한다.
		//  → int 형으로 강제 형 변환
		int n3 = (int)10.5; // 강제 형 변환에 의해 10 으로 변환
		System.out.println("n3 = " + n3);
		// int 형 데이터를 byte 형 변수에 저장시킬 수 없기 때문에
		// 컴파일 오류가 발생한다.
		byte n4 = (byte)356;
		System.out.println("n4 = " + n4);
		
		double n5 = 10 / 7;
		// double n5 = 1;    → 좌측 피 연산자의 결과 = 1
		// double n5 = 1.0;  → 1 을 double 형 변수에 저장시키기 위해 실수형으로 변환
		System.out.println("n5 = " + n5);
		
		double n6 = (double)10 / 7;
		// double n6 = 10.0 / 7; 	→ 10 을 double 형으로 강제 형 변환
		// double n6 = 10.0 / 7.0; 	→ 7 을 double 형으로 자동 형 변환
		// double n6 = 1.4285714285714286;
		System.out.println("n6 = " + n6);
		//--------------------------------------------------------------------------------
		// 산술 연산자
		//  - 나누기 연산자(/)와 나머지 연산자(%)의 활용
		//		1. 단위 변환
		//			kg ↔ g, byte ↔ bit, won ↔ $
		//		2. 배수 검사
		//			n 의 배수 : n * 1, n * 2, n * 3 ... 
		//					  : n 으로 나누어떨어지는 수
		//					  : n 으로 나눴을 때 나머지가 0 인 수
		//		3. 그룹 관련 활용
		//			108개의 게시글이 있을 때 이를 10 개씩 출력한다면
		//			 총 페이지 수 : (108 / 10) + 1
		//			 마지막 페이지의 게시글 수 : 108 % 10
		//			 n 번째 게시글이 위치한 페이지 : (n / 10) + 1
		
		
		// ----------------------------------------------------------------------
		// 대입 연산자
		//	- 저장 공간에 표현식의 결과를 저장하기 위한 연산자
		//	- 대입 연산자의 우측 표현식의 결과를 좌측 저장 공간에 저장
		//	- 다른 연산자와 합쳐진 복합 대입 연산자도 있다.
		//		→ 저장 공간에 저장된 값을 다른 연산을 통해 변화를 줄 때 사용
		//		→ 대입 연산자의 좌측 변수와 다른 연산자의 좌측 변수가 동일한 경우에
		//		  복합 대입 연산자로 작성이 가능하다.
		//		→ 산술 연산자와 비트 연산자를 복합 대입 연산자로 작성이 가능하다.
		
		int a = 10;
		System.out.println("a = " + a);
		
		// a 의 값을 10 만큼 증가
		a = a + 10;
		// a = 10 + 10;
		// a = 20;
		System.out.println("a = " + a);
		
		// a의 값을 10 만큼 증가
		a += 10;
		System.out.println("a = " + a);
		
		// a 의 값을 10 만큼 감소
		a -= 10; // → a = a - 10;
		
		// a에 10 에서 뺀 값을 저장
		a = 10 - a; // → 복합 대입 연산자로 표현이 될 수 없다.
		//------------------------------------------------------------------
		// 증감 연산자
		//	- 저장 공간에 저장된 값을 1 만큼 증가 또는 감소시키는 연산자
		//	- 저장 공강만 지정하면 되기 때문에 단항 연산자로 사용된다.
		//	- 종류
		//		++ : 1 증가
		//		-- : 1 감소
		// 	- 연산자의 작성 위치에 따라 연산 결과가 다르다.
		//		전위(prefix) 증가 : 증감된 값을 반환
		//		후위(postfix) 증감 : 증감되기 전의 값을 반환
		int b = 0;
		int c = 0;
		System.out.println("b = " + b);
		System.out.println("c = " + c);
		
		int prefix = ++b;	// 변수 b의 값을 1 증가, 증가된 값을 반환
		int postfix = c++;	// 변수 c의 값을 1 증가, 증가되기 전의 값을 반환
		System.out.println("++b = " + prefix);
		System.out.println("c++ = " + postfix);
		System.out.println("b = " + b); //1
		System.out.println("c = " + c); //1
		
		System.out.println("(++b)*2 = " + (++b)*2);
		// System.out.println("(++b)*2 = " + (2)*2);
		// System.out.println("(++b)*2 = " + 4);
		
		System.out.println("(c++)*2 = " + (c++)*2);
		// System.out.println("(c++)*2 = " + (1)*2);
		// System.out.println("(c++)*2 = " + 2);
		//------------------------------------------------------------------
		// 관계 연산자( = 비교 연산자)
		//	- 데이터의 대소 관계를 비교하는 연산자
		//	- 연산자의 결과 값은 논리 값(true, false)으로 반환
		//		ex) 나이가 20살 이상, 점수가 80점 이상
		//	- 프로그램의 흐름을 제어하기 위한 제어문에서 
		//	  조건식을 만들 때 사용된다.
		//	- 종류
		//		비교 연산자
		//		  : 대소 관계를 비교하는 연산자
		//		  : >, <, >=, <=
		//		상등 비교 연산자
		//		  : 값의 일치 여부를 비교하는 연산자
		//		  : ==, !=
		
		int d = 10;
		
		// d 가 10 보다 크다. = 초과
		System.out.println(d + " > 10 : " + (d > 10));
		
		// d 가 10 보다 크거나 같다. = 이상
		System.out.println(d + " >= 10 : " + (d >= 10));
		
		// d 가 10 보다 작다. = 미만
		System.out.println(d + " < 10 : " + (d < 10));
		
		// d 가 10 보다 작거나 같다. = 이하
		System.out.println(d + " <= 10 : " + (d <= 10));
		
		// d 가 10 과 같다.
		System.out.println(d + " == 10 : " + (d == 10));
		
		// d 가 10 과 다르다.
		System.out.println(d + " != 10 : " + (d != 10));
		
		
		// 비교 연산자를 통해 범위를 표현할 수 없다.
		//	0 <= x < 10
		// int x = 5;
		// System.out.println("0 <= x < 10 : " + (0 <= x < 10));
		//	→ 문법 오류
		//	→ Java 에서는 다수의 연산자를 한 번에 연산하지 않고
		//	  차례대로 연산을 한다.
		//	→ (0 <= x < 10) → (true < 10)
		//	    : 비교 연산자는 논리 값을 비교할 수 없다.
		//	→ 위와 같은 범위를 표현하려면 논리 연산자를 이용
		//------------------------------------------------------------
		
		// 논리 연산자
		//	- 논리 값(true, false)을 연산하기 위한 연산자
		//	- 연산자의 결과 값의 타입도 논리 값이다.
		//	- 종류
		//		- && 연산자(AND 연산자)
		//			: 두 논리 값이 true 인 경우 true 를 반환
		//			: 두 논리 값을 만족해야하는 경우 사용
		//		- || 연산자(OR 연산자)
		//			: 두 논리 값 중 하나라도 true 이면 true 를 반환
		//			: 두 논리 값 중 하나라도 만족해야하는 경우 사용
		//		-  ! 연산자(NOT 연산자)
		//			: 논리 값의 반대 논리 값으로 반환
		//		- ^ 연산자(XOR 연산자), 베타적 논리 합
		//			: 두 논리 값 중 하나만 true 이면 true 를 반환
		//			: 두 논리 값 중 하나만 만족해야하는 경우 사용
		
		// && 연산자(AND 연산자) = 논리 곱
		// 과목 A 가 50점 이상이고 과목 B가 60점 이상인지 검사
		int subjectA = 45;
		int subjectB = 70;
	
		// 과목 A 가 50점 이상
		boolean resultA = subjectA >= 50;
		
		// 과목 B 가 60점 이상
		boolean resultB = subjectB >= 60;
		
		// 둘 다 만족하는지 검사
		boolean result1 = resultA && resultB;
		// boolean result1 = false && true;
		// boolean result1 = false;
		
		System.out.println("Subject A : " + subjectA);
		System.out.println("Subject B : " +subjectB);
		System.out.println("Result1	: " +result1);
		
		// || 연산자(OR 연산자) = 논리 합
		// 과목 A 가 50점 이상이거나 과목 B가 60점 이상인지 검사
		boolean result2 = resultA || resultB;
		// boolean result2 = false || true;
		// boolean result2 = true;
		System.out.println("Result2 : " +result2);
		
		// ! 연산자(NOT 연산자) = 부정
		//	조건이 아니다.
		//	- 이미 구해진 논리 값의 반대 값을 이용해야하는 경우
		//	- 드모르간의 법칙을 이용하여 논리 식을 작성할 때 이용
		int e = 15;
		boolean isEven = e % 2 == 0; // 짝수인지 검사
		
		// 홀수 = 짝수가 아닌 수 = 짝수가 아닌지 검사
		System.out.println("홀수인지 검사 : " + !isEven);
		//--------------------------------------------------------
		// 단락 평가(short-circuit evaluation)
		//	- 두 개의 논리 연산을 수행할 때 첫번째 값을 통해
		//	  결과를 알 수 있을 때 두 번째 값을 평가하지 않는 기능
		//	- 경우의 수
		//		&& 연산자 : 첫번째 논리 값이 false 인 경우 두번째를 확인하지 않는다.
		//		|| 연산자 : 첫번째 논리 값이 true 인 경우 두번째를 확인하지 않는다.
		
		int m = 0;
		// boolean result3 = true && (m++ > 0); // m 의 값이 1 증가
		boolean result3 = false && (m++ > 0); 	// m 의 값이 증가되지 않는다. 
		System.out.println("m = " + m);
	}
}










































